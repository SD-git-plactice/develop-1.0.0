
簡潔に未プッシュのコミットを確認したい場合
git log --oneline origin/ブランチ名..HEAD

基本的なコミット履歴の表示
git log

コミット履歴を1行に簡潔に表示したい場合
git log --oneline

特定のコミットで行われた変更内容を詳細に表示
git show <コミットID>

特定のコミットで変更されたファイルのリストを表示
git diff-tree --no-commit-id --name-only -r <コミットID>

直前のコミットを取り消す（変更内容をステージングエリアに戻す。変更は残る。）[--soft]⇒ローカルリポジトリ内のコミット履歴に対してのみ影響を与える
git reset --soft HEAD^



間違ってpushしてしまった。そのpushを無かったことにしたい。
↓
＜非推奨のやり方＞
git checkout <戻したい履歴のコミットID>
git reset --hard <戻したい履歴のコミットID>                     [--hard] ステージングエリアと作業ディレクトリが完全にリセットされます。すべての未保存の変更（コミットされていない変更）は完全に失われる
git push -f　（強制的にリモートリポジトリもその状態に戻す）
⇒これを行うと、他のメンバーが誤ったコミットID3を既にpullしている場合は他メンバーの作業での衝突など影響を与えるので使用は避けた方が無難

＜代替手段＞
git revert <誤ったコミットID>
↓
（誤ったコミットを取り消す操作がステージングされる）コンソールがvimになるので :q!で抜ける
↓
commit
↓
push
↓
これで、バージョンを上げる形で間違ったpushが事実上ロールバックされたような資産状態になる（ので他メンバにも影響を与えにくい）


pushすると謎の履歴ができる？
↓
マージコミットと呼ばれるもの
↓
なぜ「謎の履歴（マージコミット）」が発生するのか？
git pull は、リモートリポジトリの最新の変更をローカルに取得し、通常は自動的にマージを行います。マージが行われる際、ローカルの変更とリモートの変更が統合され、その結果としてマージコミットが作成されます。
このマージコミットは、ローカルとリモートのブランチが異なっている場合に、その2つの履歴を結びつけるために自動的に作成されます。このため、Gitのログには以下のような履歴が表示されることになります。
自分が前回 pull した時点のリモートリポジトリの状態
その後リモートに他の人が push した変更点
自分が今回 pull してマージした結果（マージコミット）
↓
このマージコミットを避けたい場合、以下の方法があります
↓
git pull --rebase
↓
git pull の代わりに git pull --rebase を使うことで、ローカルのコミットをリモートの履歴に再適用される
↓
やってみたら、ローカルの変更が未ステージの状態であると、リベースできないので使いずらそう








